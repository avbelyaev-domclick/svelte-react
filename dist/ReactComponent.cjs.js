'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var internal = require('svelte/internal');
var React = _interopDefault(require('react'));
var ReactDOM = _interopDefault(require('react-dom'));
var svelte = require('svelte');

/* ReactComponent.svelte generated by Svelte v3.9.1 */

function create_fragment(ctx) {
	var span;

	return {
		c() {
			span = internal.element("span");
		},

		m(target, anchor) {
			internal.insert(target, span, anchor);
			ctx.span_binding(span);
		},

		p: internal.noop,
		i: internal.noop,
		o: internal.noop,

		d(detaching) {
			if (detaching) {
				internal.detach(span);
			}

			ctx.span_binding(null);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	

  let { children, component } = $$props;

  let root;

  svelte.afterUpdate(render);

  async function render() {
    const props = Object.assign({}, $$props);
    delete props.children;
    delete props.component;

    ReactDOM.render(React.createElement(component, props, children), root);
  }

	function span_binding($$value) {
		internal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('root', root = $$value);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = internal.assign(internal.assign({}, $$props), $$new_props));
		if ('children' in $$new_props) $$invalidate('children', children = $$new_props.children);
		if ('component' in $$new_props) $$invalidate('component', component = $$new_props.component);
	};

	return {
		children,
		component,
		root,
		span_binding,
		$$props: $$props = internal.exclude_internal_props($$props)
	};
}

class ReactComponent extends internal.SvelteComponent {
	constructor(options) {
		super();
		internal.init(this, options, instance, create_fragment, internal.safe_not_equal, ["children", "component"]);
	}
}

module.exports = ReactComponent;
